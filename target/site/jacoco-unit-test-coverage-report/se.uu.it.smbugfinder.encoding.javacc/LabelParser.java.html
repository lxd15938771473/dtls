<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LabelParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">state-machine-bug-finder</a> &gt; <a href="index.source.html" class="el_package">se.uu.it.smbugfinder.encoding.javacc</a> &gt; <span class="el_source">LabelParser.java</span></div><h1>LabelParser.java</h1><pre class="source lang-java linenums">/* LabelParser.java */
/* Generated By:JavaCC: Do not edit this line. LabelParser.java */
package se.uu.it.smbugfinder.encoding.javacc;

import java.util.*;

import se.uu.it.smbugfinder.encoding.*;

class LabelParser extends AbstractLabelParser implements LabelParserConstants {

  final public Label label() throws ParseException {DescriptionToken description;
<span class="fc" id="L12">    Guard guard = new Guard();</span>
    BooleanExpression expr;
<span class="fc" id="L14">    Update update = new Update();</span>
<span class="fc" id="L15">    description = description();</span>
<span class="pc bpc" id="L16" title="1 of 4 branches missed.">    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
    case UPDATE_START:{
<span class="fc" id="L18">      jj_consume_token(UPDATE_START);</span>
<span class="pc bpc" id="L19" title="1 of 2 branches missed.">      if (jj_2_1(2)) {</span>
<span class="fc" id="L20">        update = update();</span>
      } else {
<span class="nc bnc" id="L22" title="All 4 branches missed.">        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
        case ID:{
<span class="nc" id="L24">          expr = restrictedExpression();</span>
<span class="nc" id="L25">guard = new Guard(expr);</span>
<span class="nc" id="L26">          break;</span>
          }
        default:
<span class="nc" id="L29">          jj_la1[0] = jj_gen;</span>
<span class="nc" id="L30">          jj_consume_token(-1);</span>
<span class="nc" id="L31">          throw new ParseException();</span>
        }
      }
<span class="fc" id="L34">      jj_consume_token(UPDATE_END);</span>
<span class="fc" id="L35">      break;</span>
      }
    default:
<span class="fc" id="L38">      jj_la1[1] = jj_gen;</span>
      ;
    }
<span class="fc bfc" id="L41" title="All 4 branches covered.">    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
    case GUARD_START:{
<span class="fc" id="L43">      jj_consume_token(GUARD_START);</span>
<span class="fc" id="L44">      guard = guard();</span>
<span class="fc" id="L45">      break;</span>
      }
    default:
<span class="fc" id="L48">      jj_la1[2] = jj_gen;</span>
      ;
    }
<span class="fc" id="L51">    jj_consume_token(0);</span>
<span class="fc" id="L52">{if (&quot;&quot; != null) return new Label(description, guard, update);}</span>
    throw new Error(&quot;Missing return statement in function&quot;);
}

<span class="fc" id="L56">  final public Update update() throws ParseException {List&lt;Assignment&gt; assignments = new ArrayList&lt;Assignment &gt;();</span>
     Assignment assignment;
     Update update;
<span class="fc" id="L59">    assignment = assignment();</span>
<span class="fc" id="L60">assignments.add(assignment);</span>
    label_1:
    while (true) {
<span class="pc bpc" id="L63" title="2 of 4 branches missed.">      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
      case UPDATE_SEP:{
        ;
<span class="nc" id="L66">        break;</span>
        }
      default:
<span class="fc" id="L69">        jj_la1[3] = jj_gen;</span>
<span class="fc" id="L70">        break label_1;</span>
      }
<span class="nc" id="L72">      jj_consume_token(UPDATE_SEP);</span>
<span class="nc" id="L73">      assignment = assignment();</span>
<span class="nc" id="L74">assignments.add(assignment);</span>
    }
<span class="fc" id="L76">update = new Update(assignments);</span>
<span class="fc" id="L77">        {if (&quot;&quot; != null) return update;}</span>
    throw new Error(&quot;Missing return statement in function&quot;);
}

  final public BooleanExpression restrictedExpression() throws ParseException {Token fieldToken, valToken;
<span class="nc" id="L82">    fieldToken = jj_consume_token(ID);</span>
<span class="nc" id="L83">    jj_consume_token(EQUAL);</span>
<span class="nc" id="L84">    valToken = jj_consume_token(ID);</span>
<span class="nc" id="L85">{if (&quot;&quot; != null) return new RelationalExpression(resolveField(fieldToken.image),  RelationalOperator.EQUAL, resolveConstant(valToken.image) );}</span>
    throw new Error(&quot;Missing return statement in function&quot;);
}

  final public Assignment assignment() throws ParseException {Token varToken, fieldToken;
<span class="fc" id="L90">    varToken = jj_consume_token(ID);</span>
<span class="fc" id="L91">    jj_consume_token(ASSIGN);</span>
<span class="fc" id="L92">    fieldToken = jj_consume_token(ID);</span>
<span class="fc" id="L93">{if (&quot;&quot; != null) return new Assignment(resolveVariable(varToken.image), resolveField(fieldToken.image) );}</span>
    throw new Error(&quot;Missing return statement in function&quot;);
}

//Guard earlyGuard():
//{
//    Token fieldToken, constToken;
//}
//{
//    fieldToken = &lt; ID &gt;
//    &lt; EQUAL &gt;
//    constToken = &lt; ID &gt;
//    {
//        BinaryBooleanExpression expr = new BinaryBooleanExpression(
//        return new Assignment(resolveVariable(varToken.image), resolveField(fieldToken.image) );
//    }
//}
  final public 
Guard guard() throws ParseException {BooleanExpression expr;
<span class="fc" id="L112">    expr = booleanExpression();</span>
<span class="fc" id="L113">{if (&quot;&quot; != null) return new Guard(expr);}</span>
    throw new Error(&quot;Missing return statement in function&quot;);
}

  final public BooleanExpression booleanExpression() throws ParseException {BooleanExpression left, right;
    LogicalOperator op;
<span class="fc" id="L119">    left = relationalExpression();</span>
    label_2:
    while (true) {
<span class="pc bpc" id="L122" title="2 of 4 branches missed.">      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
      case BODY_SEP:{
        ;
<span class="nc" id="L125">        break;</span>
        }
      default:
<span class="fc" id="L128">        jj_la1[4] = jj_gen;</span>
<span class="fc" id="L129">        break label_2;</span>
      }
<span class="nc" id="L131">      jj_consume_token(BODY_SEP);</span>
<span class="nc bnc" id="L132" title="All 5 branches missed.">      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
      case AND:{
<span class="nc" id="L134">        jj_consume_token(AND);</span>
<span class="nc" id="L135">op = LogicalOperator.AND;</span>
<span class="nc" id="L136">        break;</span>
        }
      case OR:{
<span class="nc" id="L139">        jj_consume_token(OR);</span>
<span class="nc" id="L140">op = LogicalOperator.OR;</span>
<span class="nc" id="L141">        break;</span>
        }
      default:
<span class="nc" id="L144">        jj_la1[5] = jj_gen;</span>
<span class="nc" id="L145">        jj_consume_token(-1);</span>
<span class="nc" id="L146">        throw new ParseException();</span>
      }
<span class="nc" id="L148">      jj_consume_token(BODY_SEP);</span>
<span class="nc" id="L149">      right = relationalExpression();</span>
<span class="nc" id="L150">left = new BinaryBooleanExpression(left, op, right);</span>
    }
<span class="fc" id="L152">{if (&quot;&quot; != null) return left;}</span>
    throw new Error(&quot;Missing return statement in function&quot;);
}

<span class="fc" id="L156">  final public RelationalExpression relationalExpression() throws ParseException {ValueExpression left = null, right = null;</span>
    RelationalOperator op;
<span class="fc" id="L158">    left = valueExpression();</span>
<span class="fc" id="L159">    jj_consume_token(BODY_SEP);</span>
<span class="pc bpc" id="L160" title="4 of 7 branches missed.">    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
    case EQUAL:{
<span class="nc" id="L162">      jj_consume_token(EQUAL);</span>
<span class="nc" id="L163">op = RelationalOperator.EQUAL;</span>
<span class="nc" id="L164">      break;</span>
      }
    case NOT_EQUAL:{
<span class="fc" id="L167">      jj_consume_token(NOT_EQUAL);</span>
<span class="fc" id="L168">op = RelationalOperator.NOT_EQUAL;</span>
<span class="fc" id="L169">      break;</span>
      }
    case IN:{
<span class="nc" id="L172">      jj_consume_token(IN);</span>
<span class="nc" id="L173">op = RelationalOperator.IN;</span>
<span class="nc" id="L174">      break;</span>
      }
    case NOT_IN:{
<span class="fc" id="L177">      jj_consume_token(NOT_IN);</span>
<span class="fc" id="L178">op = RelationalOperator.NOT_IN;</span>
<span class="fc" id="L179">      break;</span>
      }
    default:
<span class="nc" id="L182">      jj_la1[6] = jj_gen;</span>
<span class="nc" id="L183">      jj_consume_token(-1);</span>
<span class="nc" id="L184">      throw new ParseException();</span>
    }
<span class="fc" id="L186">    jj_consume_token(BODY_SEP);</span>
<span class="fc" id="L187">    right = valueExpression();</span>
<span class="fc" id="L188">{if (&quot;&quot; != null) return new RelationalExpression(left, op, right);}</span>
    throw new Error(&quot;Missing return statement in function&quot;);
}

  final public ValueExpression valueExpression() throws ParseException {Token idToken, argToken;
<span class="fc" id="L193">    ValueExpression expression = null, argument = null;</span>
<span class="fc" id="L194">    idToken = jj_consume_token(ID);</span>
<span class="pc bpc" id="L195" title="1 of 4 branches missed.">    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
    case INV_START:{
<span class="fc" id="L197">      jj_consume_token(INV_START);</span>
<span class="fc" id="L198">java.util.List&lt;ValueExpression&gt; arguments = new java.util.ArrayList&lt;ValueExpression&gt;();</span>
<span class="pc bpc" id="L199" title="2 of 4 branches missed.">      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
      case ID:{
<span class="fc" id="L201">        argument = valueExpression();</span>
//arguments.add(new Variable(argToken.image));
<span class="fc" id="L203">                arguments.add(argument);</span>
        label_3:
        while (true) {
<span class="pc bpc" id="L206" title="2 of 4 branches missed.">          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
          case INV_SEP:{
            ;
<span class="nc" id="L209">            break;</span>
            }
          default:
<span class="fc" id="L212">            jj_la1[7] = jj_gen;</span>
<span class="fc" id="L213">            break label_3;</span>
          }
<span class="nc" id="L215">          jj_consume_token(INV_SEP);</span>
          //                argToken = &lt; ID &gt;
          //                {
          //                    arguments.add(new Variable(argToken.image));
          //                }
<span class="nc" id="L220">                          argument = valueExpression();</span>
<span class="nc" id="L221">arguments.add(argument);</span>
        }
        break;
        }
      default:
<span class="nc" id="L226">        jj_la1[8] = jj_gen;</span>
        ;
      }
<span class="fc" id="L229">      jj_consume_token(INV_END);</span>
<span class="fc" id="L230">Function fun = resolveFunction(idToken.image);</span>
<span class="fc" id="L231">            expression = new FunctionInvocation(fun, arguments);</span>
<span class="fc" id="L232">      break;</span>
      }
    default:
<span class="fc" id="L235">      jj_la1[9] = jj_gen;</span>
      ;
    }
<span class="fc bfc" id="L238" title="All 2 branches covered.">if (expression == null) {</span>
<span class="fc" id="L239">            expression = resolveValueExpression(idToken.image);</span>
        }
<span class="fc" id="L241">        {if (&quot;&quot; != null) return expression;}</span>
    throw new Error(&quot;Missing return statement in function&quot;);
}

  final public FunctionInvocation invocation() throws ParseException {Token idToken;
    Function fun;
<span class="nc" id="L247">    List&lt;ValueExpression&gt; parameters = new ArrayList&lt;ValueExpression &gt;();</span>
<span class="nc" id="L248">    idToken = jj_consume_token(ID);</span>
<span class="nc" id="L249">fun = resolveFunction(idToken.image);</span>
<span class="nc bnc" id="L250" title="All 4 branches missed.">    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
    case INV_START:{
<span class="nc" id="L252">      jj_consume_token(INV_START);</span>
<span class="nc bnc" id="L253" title="All 4 branches missed.">      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
      case ID:{
<span class="nc" id="L255">        idToken = jj_consume_token(ID);</span>
<span class="nc" id="L256">parameters.add(new Variable(idToken.image));</span>
        label_4:
        while (true) {
<span class="nc bnc" id="L259" title="All 4 branches missed.">          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
          case INV_SEP:{
            ;
<span class="nc" id="L262">            break;</span>
            }
          default:
<span class="nc" id="L265">            jj_la1[10] = jj_gen;</span>
<span class="nc" id="L266">            break label_4;</span>
          }
<span class="nc" id="L268">          jj_consume_token(INV_SEP);</span>
<span class="nc" id="L269">          idToken = jj_consume_token(ID);</span>
<span class="nc" id="L270">parameters.add(new Variable(idToken.image));</span>
        }
        break;
        }
      default:
<span class="nc" id="L275">        jj_la1[11] = jj_gen;</span>
        ;
      }
<span class="nc" id="L278">      jj_consume_token(INV_END);</span>
<span class="nc" id="L279">      break;</span>
      }
    default:
<span class="nc" id="L282">      jj_la1[12] = jj_gen;</span>
      ;
    }
<span class="nc" id="L285">{if (&quot;&quot; != null) return new FunctionInvocation(fun, parameters);}</span>
    throw new Error(&quot;Missing return statement in function&quot;);
}

<span class="fc" id="L289">  final public DescriptionToken description() throws ParseException {DescriptionToken left = null;</span>
<span class="fc" id="L290">    SetOperator op = null;</span>
<span class="fc" id="L291">    DescriptionToken right = null;</span>
<span class="pc bpc" id="L292" title="2 of 7 branches missed.">    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
    case ENUM_START:{
<span class="fc" id="L294">      left = enumtoken();</span>
<span class="fc" id="L295">      break;</span>
      }
    case FILTER:{
<span class="fc" id="L298">      left = regex();</span>
<span class="fc" id="L299">      break;</span>
      }
    case OTHER:
    case OTHER_INPUT:
    case OTHER_OUTPUT:{
<span class="fc" id="L304">      left = other();</span>
<span class="fc" id="L305">      break;</span>
      }
    case INPUT:
    case OUTPUT:
    case SYMBOL:{
<span class="fc" id="L310">      left = symbol();</span>
<span class="fc" id="L311">      break;</span>
      }
    default:
<span class="nc" id="L314">      jj_la1[13] = jj_gen;</span>
<span class="nc" id="L315">      jj_consume_token(-1);</span>
<span class="nc" id="L316">      throw new ParseException();</span>
    }
    label_5:
    while (true) {
<span class="fc bfc" id="L320" title="All 2 branches covered.">      if (jj_2_2(2)) {</span>
        ;
      } else {
        break label_5;
      }
<span class="fc" id="L325">      jj_consume_token(SEP);</span>
<span class="fc" id="L326">      op = setOperator();</span>
<span class="fc" id="L327">      jj_consume_token(SEP);</span>
<span class="pc bpc" id="L328" title="2 of 6 branches missed.">      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
      case FILTER:{
<span class="fc" id="L330">        right = regex();</span>
<span class="fc" id="L331">        break;</span>
        }
      case ENUM_START:{
<span class="fc" id="L334">        right = enumtoken();</span>
<span class="fc" id="L335">        break;</span>
        }
      case INPUT:
      case OUTPUT:
      case SYMBOL:{
<span class="fc" id="L340">        right = symbol();</span>
<span class="fc" id="L341">        break;</span>
        }
      default:
<span class="nc" id="L344">        jj_la1[14] = jj_gen;</span>
<span class="nc" id="L345">        jj_consume_token(-1);</span>
<span class="nc" id="L346">        throw new ParseException();</span>
      }
<span class="fc" id="L348">left = new SetExpressionToken(left, op, right);</span>
    }
<span class="fc" id="L350">{if (&quot;&quot; != null) return left;}</span>
    throw new Error(&quot;Missing return statement in function&quot;);
}

  final public SymbolToken symbol() throws ParseException {SymbolToken s;
<span class="pc bpc" id="L355" title="3 of 6 branches missed.">    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
    case INPUT:{
<span class="fc" id="L357">      s = input();</span>
<span class="fc" id="L358">      break;</span>
      }
    case OUTPUT:{
<span class="fc" id="L361">      s = output();</span>
<span class="fc" id="L362">      break;</span>
      }
    case SYMBOL:{
<span class="nc" id="L365">      s = anySymbol();</span>
<span class="nc" id="L366">      break;</span>
      }
    default:
<span class="nc" id="L369">      jj_la1[15] = jj_gen;</span>
<span class="nc" id="L370">      jj_consume_token(-1);</span>
<span class="nc" id="L371">      throw new ParseException();</span>
    }
<span class="fc" id="L373">{if (&quot;&quot; != null) return s;}</span>
    throw new Error(&quot;Missing return statement in function&quot;);
}

  final public SymbolToken input() throws ParseException {Token msgToken;
<span class="fc" id="L378">    msgToken = jj_consume_token(INPUT);</span>
<span class="fc" id="L379">{if (&quot;&quot; != null) return new SymbolToken(true, msgToken.image.substring(2));}</span>
    throw new Error(&quot;Missing return statement in function&quot;);
}

  final public SymbolToken output() throws ParseException {Token msgToken;
<span class="fc" id="L384">    msgToken = jj_consume_token(OUTPUT);</span>
<span class="fc" id="L385">{if (&quot;&quot; != null) return new SymbolToken(false, msgToken.image.substring(2));}</span>
    throw new Error(&quot;Missing return statement in function&quot;);
}

  final public SymbolToken anySymbol() throws ParseException {Token msgToken;
<span class="nc" id="L390">    msgToken = jj_consume_token(SYMBOL);</span>
<span class="nc" id="L391">{if (&quot;&quot; != null) return new SymbolToken(msgToken.image);}</span>
    throw new Error(&quot;Missing return statement in function&quot;);
}

  final public RegexToken regex() throws ParseException {Token regexToken;
<span class="fc" id="L396">    regexToken = jj_consume_token(FILTER);</span>
<span class="fc" id="L397">{if (&quot;&quot; != null) return new RegexToken(regexToken.image.substring(2));}</span>
    throw new Error(&quot;Missing return statement in function&quot;);
}

<span class="fc" id="L401">  final public OtherToken other() throws ParseException {OtherTokenType otherType = null;</span>
<span class="pc bpc" id="L402" title="2 of 6 branches missed.">    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
    case OTHER:{
<span class="fc" id="L404">      jj_consume_token(OTHER);</span>
<span class="fc" id="L405">otherType = OtherTokenType.ALL;</span>
<span class="fc" id="L406">      break;</span>
      }
    case OTHER_INPUT:{
<span class="fc" id="L409">      jj_consume_token(OTHER_INPUT);</span>
<span class="fc" id="L410">otherType = OtherTokenType.INPUT;</span>
<span class="fc" id="L411">      break;</span>
      }
    case OTHER_OUTPUT:{
<span class="fc" id="L414">      jj_consume_token(OTHER_OUTPUT);</span>
<span class="fc" id="L415">otherType = OtherTokenType.OUTPUT;</span>
<span class="fc" id="L416">      break;</span>
      }
    default:
<span class="nc" id="L419">      jj_la1[16] = jj_gen;</span>
<span class="nc" id="L420">      jj_consume_token(-1);</span>
<span class="nc" id="L421">      throw new ParseException();</span>
    }
<span class="fc" id="L423">{if (&quot;&quot; != null) return new OtherToken(otherType);}</span>
    throw new Error(&quot;Missing return statement in function&quot;);
}

<span class="fc" id="L427">  final public EnumerationToken enumtoken() throws ParseException {java.util.List&lt;SymbolToken&gt; symbols = new java.util.ArrayList&lt;SymbolToken&gt;();</span>
    SymbolToken symbol;
<span class="fc" id="L429">    jj_consume_token(ENUM_START);</span>
<span class="fc" id="L430">    symbol = element();</span>
<span class="fc" id="L431">symbols.add(symbol);</span>
    label_6:
    while (true) {
<span class="pc bpc" id="L434" title="1 of 4 branches missed.">      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
      case ENUM_SEP:{
        ;
<span class="fc" id="L437">        break;</span>
        }
      default:
<span class="fc" id="L440">        jj_la1[17] = jj_gen;</span>
<span class="fc" id="L441">        break label_6;</span>
      }
<span class="fc" id="L443">      jj_consume_token(ENUM_SEP);</span>
<span class="fc" id="L444">      symbol = element();</span>
<span class="fc" id="L445">symbols.add(symbol);</span>
    }
<span class="fc" id="L447">    jj_consume_token(ENUM_END);</span>
<span class="fc" id="L448">{if (&quot;&quot; != null) return new EnumerationToken(symbols);}</span>
    throw new Error(&quot;Missing return statement in function&quot;);
}

  final public SymbolToken element() throws ParseException {Boolean input;
<span class="fc" id="L453">    Token msgToken = null;</span>
<span class="fc" id="L454">    String symbolString = null;</span>
<span class="pc bpc" id="L455" title="3 of 6 branches missed.">    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
    case INPUT_ELEMENT:{
<span class="fc" id="L457">      msgToken = jj_consume_token(INPUT_ELEMENT);</span>
<span class="fc" id="L458">input = true; symbolString = msgToken.image.substring(2);</span>
<span class="fc" id="L459">      break;</span>
      }
    case OUTPUT_ELEMENT:{
<span class="fc" id="L462">      msgToken = jj_consume_token(OUTPUT_ELEMENT);</span>
<span class="fc" id="L463">input = false; symbolString = msgToken.image.substring(2);</span>
<span class="fc" id="L464">      break;</span>
      }
    case SYMBOL_ELEMENT:{
<span class="nc" id="L467">      msgToken = jj_consume_token(SYMBOL_ELEMENT);</span>
<span class="nc" id="L468">input = null; symbolString = msgToken.image;</span>
<span class="nc" id="L469">      break;</span>
      }
    default:
<span class="nc" id="L472">      jj_la1[18] = jj_gen;</span>
<span class="nc" id="L473">      jj_consume_token(-1);</span>
<span class="nc" id="L474">      throw new ParseException();</span>
    }
<span class="fc" id="L476">{if (&quot;&quot; != null) return new SymbolToken(input, symbolString);}</span>
    throw new Error(&quot;Missing return statement in function&quot;);
}

  final public SetOperator setOperator() throws ParseException {SetOperator op;
<span class="pc bpc" id="L481" title="2 of 5 branches missed.">    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {</span>
    case DIFFERENCE:{
<span class="fc" id="L483">      jj_consume_token(DIFFERENCE);</span>
<span class="fc" id="L484">op = SetOperator.DIFFERENCE;</span>
<span class="fc" id="L485">      break;</span>
      }
    case UNION:{
<span class="fc" id="L488">      jj_consume_token(UNION);</span>
<span class="fc" id="L489">op = SetOperator.UNION;</span>
<span class="fc" id="L490">      break;</span>
      }
    default:
<span class="nc" id="L493">      jj_la1[19] = jj_gen;</span>
<span class="nc" id="L494">      jj_consume_token(-1);</span>
<span class="nc" id="L495">      throw new ParseException();</span>
    }
<span class="fc" id="L497">{if (&quot;&quot; != null) return op;}</span>
    throw new Error(&quot;Missing return statement in function&quot;);
}

  private boolean jj_2_1(int xla)
 {
<span class="fc" id="L503">    jj_la = xla; jj_lastpos = jj_scanpos = token;</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">    try { return (!jj_3_1()); }</span>
<span class="fc" id="L505">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="fc" id="L506">    finally { jj_save(0, xla); }</span>
  }

  private boolean jj_2_2(int xla)
 {
<span class="fc" id="L511">    jj_la = xla; jj_lastpos = jj_scanpos = token;</span>
<span class="pc bpc" id="L512" title="1 of 2 branches missed.">    try { return (!jj_3_2()); }</span>
<span class="fc" id="L513">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="fc" id="L514">    finally { jj_save(1, xla); }</span>
  }

  private boolean jj_3_2()
 {
<span class="pc bpc" id="L519" title="1 of 2 branches missed.">    if (jj_scan_token(SEP)) return true;</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">    if (jj_3R_setOperator_513_5_8()) return true;</span>
<span class="nc" id="L521">    return false;</span>
  }

  private boolean jj_3R_update_124_5_7()
 {
<span class="nc bnc" id="L526" title="All 2 branches missed.">    if (jj_3R_assignment_160_5_9()) return true;</span>
<span class="nc" id="L527">    return false;</span>
  }

  private boolean jj_3R_setOperator_514_9_10()
 {
<span class="pc bpc" id="L532" title="1 of 2 branches missed.">    if (jj_scan_token(DIFFERENCE)) return true;</span>
<span class="nc" id="L533">    return false;</span>
  }

  private boolean jj_3_1()
 {
<span class="nc bnc" id="L538" title="All 2 branches missed.">    if (jj_3R_update_124_5_7()) return true;</span>
<span class="nc" id="L539">    return false;</span>
  }

  private boolean jj_3R_setOperator_517_13_11()
 {
<span class="nc bnc" id="L544" title="All 2 branches missed.">    if (jj_scan_token(UNION)) return true;</span>
<span class="nc" id="L545">    return false;</span>
  }

  private boolean jj_3R_setOperator_513_5_8()
 {
    Token xsp;
<span class="fc" id="L551">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L552" title="1 of 2 branches missed.">    if (jj_3R_setOperator_514_9_10()) {</span>
<span class="fc" id="L553">    jj_scanpos = xsp;</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">    if (jj_3R_setOperator_517_13_11()) return true;</span>
    }
<span class="nc" id="L556">    return false;</span>
  }

  private boolean jj_3R_assignment_160_5_9()
 {
<span class="nc bnc" id="L561" title="All 2 branches missed.">    if (jj_scan_token(ID)) return true;</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">    if (jj_scan_token(ASSIGN)) return true;</span>
<span class="nc" id="L563">    return false;</span>
  }

  /** Generated Token Manager. */
  public LabelParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
<span class="pc" id="L577">  final private int[] jj_la1 = new int[20];</span>
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
<span class="fc" id="L581">	   jj_la1_init_0();</span>
<span class="fc" id="L582">	   jj_la1_init_1();</span>
	}
	private static void jj_la1_init_0() {
<span class="fc" id="L585">	   jj_la1_0 = new int[] {0x200000,0x80,0x800,0x200,0x400000,0x18000,0x1e0000,0x2000,0x200000,0x1000,0x2000,0x200000,0x1000,0x7f800000,0x63800000,0x21800000,0x1c000000,0x0,0x80000000,0x30,};</span>
<span class="fc" id="L586">	}</span>
	private static void jj_la1_init_1() {
<span class="fc" id="L588">	   jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x3,0x0,};</span>
<span class="fc" id="L589">	}</span>
<span class="pc" id="L590">  final private JJCalls[] jj_2_rtns = new JJCalls[2];</span>
<span class="pc" id="L591">  private boolean jj_rescan = false;</span>
<span class="pc" id="L592">  private int jj_gc = 0;</span>

  /** Constructor with InputStream. */
  public LabelParser(java.io.InputStream stream) {
<span class="nc" id="L596">	  this(stream, null);</span>
<span class="nc" id="L597">  }</span>
  /** Constructor with InputStream and supplied encoding */
<span class="nc" id="L599">  public LabelParser(java.io.InputStream stream, String encoding) {</span>
<span class="nc" id="L600">	 try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }</span>
<span class="nc" id="L601">	 token_source = new LabelParserTokenManager(jj_input_stream);</span>
<span class="nc" id="L602">	 token = new Token();</span>
<span class="nc" id="L603">	 jj_ntk = -1;</span>
<span class="nc" id="L604">	 jj_gen = 0;</span>
<span class="nc bnc" id="L605" title="All 2 branches missed.">	 for (int i = 0; i &lt; 20; i++) jj_la1[i] = -1;</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">	 for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();</span>
<span class="nc" id="L607">  }</span>

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
<span class="nc" id="L611">	  ReInit(stream, null);</span>
<span class="nc" id="L612">  }</span>
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
<span class="nc" id="L615">	 try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }</span>
<span class="nc" id="L616">	 token_source.ReInit(jj_input_stream);</span>
<span class="nc" id="L617">	 token = new Token();</span>
<span class="nc" id="L618">	 jj_ntk = -1;</span>
<span class="nc" id="L619">	 jj_gen = 0;</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">	 for (int i = 0; i &lt; 20; i++) jj_la1[i] = -1;</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">	 for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();</span>
<span class="nc" id="L622">  }</span>

  /** Constructor. */
<span class="fc" id="L625">  public LabelParser(java.io.Reader stream) {</span>
<span class="fc" id="L626">	 jj_input_stream = new SimpleCharStream(stream, 1, 1);</span>
<span class="fc" id="L627">	 token_source = new LabelParserTokenManager(jj_input_stream);</span>
<span class="fc" id="L628">	 token = new Token();</span>
<span class="fc" id="L629">	 jj_ntk = -1;</span>
<span class="fc" id="L630">	 jj_gen = 0;</span>
<span class="fc bfc" id="L631" title="All 2 branches covered.">	 for (int i = 0; i &lt; 20; i++) jj_la1[i] = -1;</span>
<span class="fc bfc" id="L632" title="All 2 branches covered.">	 for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();</span>
<span class="fc" id="L633">  }</span>

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
<span class="nc bnc" id="L637" title="All 2 branches missed.">	if (jj_input_stream == null) {</span>
<span class="nc" id="L638">	   jj_input_stream = new SimpleCharStream(stream, 1, 1);</span>
	} else {
<span class="nc" id="L640">	   jj_input_stream.ReInit(stream, 1, 1);</span>
	}
<span class="nc bnc" id="L642" title="All 2 branches missed.">	if (token_source == null) {</span>
<span class="nc" id="L643"> token_source = new LabelParserTokenManager(jj_input_stream);</span>
	}

<span class="nc" id="L646">	 token_source.ReInit(jj_input_stream);</span>
<span class="nc" id="L647">	 token = new Token();</span>
<span class="nc" id="L648">	 jj_ntk = -1;</span>
<span class="nc" id="L649">	 jj_gen = 0;</span>
<span class="nc bnc" id="L650" title="All 2 branches missed.">	 for (int i = 0; i &lt; 20; i++) jj_la1[i] = -1;</span>
<span class="nc bnc" id="L651" title="All 2 branches missed.">	 for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();</span>
<span class="nc" id="L652">  }</span>

  /** Constructor with generated Token Manager. */
<span class="nc" id="L655">  public LabelParser(LabelParserTokenManager tm) {</span>
<span class="nc" id="L656">	 token_source = tm;</span>
<span class="nc" id="L657">	 token = new Token();</span>
<span class="nc" id="L658">	 jj_ntk = -1;</span>
<span class="nc" id="L659">	 jj_gen = 0;</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">	 for (int i = 0; i &lt; 20; i++) jj_la1[i] = -1;</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">	 for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();</span>
<span class="nc" id="L662">  }</span>

  /** Reinitialise. */
  public void ReInit(LabelParserTokenManager tm) {
<span class="nc" id="L666">	 token_source = tm;</span>
<span class="nc" id="L667">	 token = new Token();</span>
<span class="nc" id="L668">	 jj_ntk = -1;</span>
<span class="nc" id="L669">	 jj_gen = 0;</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">	 for (int i = 0; i &lt; 20; i++) jj_la1[i] = -1;</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">	 for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();</span>
<span class="nc" id="L672">  }</span>

  private Token jj_consume_token(int kind) throws ParseException {
	 Token oldToken;
<span class="fc bfc" id="L676" title="All 2 branches covered.">	 if ((oldToken = token).next != null) token = token.next;</span>
<span class="fc" id="L677">	 else token = token.next = token_source.getNextToken();</span>
<span class="fc" id="L678">	 jj_ntk = -1;</span>
<span class="pc bpc" id="L679" title="1 of 2 branches missed.">	 if (token.kind == kind) {</span>
<span class="fc" id="L680">	   jj_gen++;</span>
<span class="pc bpc" id="L681" title="1 of 2 branches missed.">	   if (++jj_gc &gt; 100) {</span>
<span class="nc" id="L682">		 jj_gc = 0;</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">		 for (int i = 0; i &lt; jj_2_rtns.length; i++) {</span>
<span class="nc" id="L684">		   JJCalls c = jj_2_rtns[i];</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">		   while (c != null) {</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">			 if (c.gen &lt; jj_gen) c.first = null;</span>
<span class="nc" id="L687">			 c = c.next;</span>
		   }
		 }
	   }
<span class="fc" id="L691">	   return token;</span>
	 }
<span class="nc" id="L693">	 token = oldToken;</span>
<span class="nc" id="L694">	 jj_kind = kind;</span>
<span class="nc" id="L695">	 throw generateParseException();</span>
  }

  @SuppressWarnings(&quot;serial&quot;)
  static private final class LookaheadSuccess extends java.lang.Error {
    @Override
    public Throwable fillInStackTrace() {
<span class="fc" id="L702">      return this;</span>
    }
  }
<span class="fc" id="L705">  static private final LookaheadSuccess jj_ls = new LookaheadSuccess();</span>
  private boolean jj_scan_token(int kind) {
<span class="fc bfc" id="L707" title="All 2 branches covered.">	 if (jj_scanpos == jj_lastpos) {</span>
<span class="fc" id="L708">	   jj_la--;</span>
<span class="pc bpc" id="L709" title="1 of 2 branches missed.">	   if (jj_scanpos.next == null) {</span>
<span class="fc" id="L710">		 jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();</span>
	   } else {
<span class="nc" id="L712">		 jj_lastpos = jj_scanpos = jj_scanpos.next;</span>
	   }
	 } else {
<span class="fc" id="L715">	   jj_scanpos = jj_scanpos.next;</span>
	 }
<span class="pc bpc" id="L717" title="1 of 2 branches missed.">	 if (jj_rescan) {</span>
<span class="nc" id="L718">	   int i = 0; Token tok = token;</span>
<span class="nc bnc" id="L719" title="All 4 branches missed.">	   while (tok != null &amp;&amp; tok != jj_scanpos) { i++; tok = tok.next; }</span>
<span class="nc bnc" id="L720" title="All 2 branches missed.">	   if (tok != null) jj_add_error_token(kind, i);</span>
	 }
<span class="fc bfc" id="L722" title="All 2 branches covered.">	 if (jj_scanpos.kind != kind) return true;</span>
<span class="pc bpc" id="L723" title="1 of 4 branches missed.">	 if (jj_la == 0 &amp;&amp; jj_scanpos == jj_lastpos) throw jj_ls;</span>
<span class="fc" id="L724">	 return false;</span>
  }


/** Get the next Token. */
  final public Token getNextToken() {
<span class="nc bnc" id="L730" title="All 2 branches missed.">	 if (token.next != null) token = token.next;</span>
<span class="nc" id="L731">	 else token = token.next = token_source.getNextToken();</span>
<span class="nc" id="L732">	 jj_ntk = -1;</span>
<span class="nc" id="L733">	 jj_gen++;</span>
<span class="nc" id="L734">	 return token;</span>
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
<span class="nc" id="L739">	 Token t = token;</span>
<span class="nc bnc" id="L740" title="All 2 branches missed.">	 for (int i = 0; i &lt; index; i++) {</span>
<span class="nc bnc" id="L741" title="All 2 branches missed.">	   if (t.next != null) t = t.next;</span>
<span class="nc" id="L742">	   else t = t.next = token_source.getNextToken();</span>
	 }
<span class="nc" id="L744">	 return t;</span>
  }

  private int jj_ntk_f() {
<span class="fc bfc" id="L748" title="All 2 branches covered.">	 if ((jj_nt=token.next) == null)</span>
<span class="fc" id="L749">	   return (jj_ntk = (token.next=token_source.getNextToken()).kind);</span>
	 else
<span class="fc" id="L751">	   return (jj_ntk = jj_nt.kind);</span>
  }

<span class="pc" id="L754">  private java.util.List&lt;int[]&gt; jj_expentries = new java.util.ArrayList&lt;int[]&gt;();</span>
  private int[] jj_expentry;
<span class="pc" id="L756">  private int jj_kind = -1;</span>
<span class="pc" id="L757">  private int[] jj_lasttokens = new int[100];</span>
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
<span class="nc bnc" id="L761" title="All 2 branches missed.">	 if (pos &gt;= 100) {</span>
<span class="nc" id="L762">		return;</span>
	 }

<span class="nc bnc" id="L765" title="All 2 branches missed.">	 if (pos == jj_endpos + 1) {</span>
<span class="nc" id="L766">	   jj_lasttokens[jj_endpos++] = kind;</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">	 } else if (jj_endpos != 0) {</span>
<span class="nc" id="L768">	   jj_expentry = new int[jj_endpos];</span>

<span class="nc bnc" id="L770" title="All 2 branches missed.">	   for (int i = 0; i &lt; jj_endpos; i++) {</span>
<span class="nc" id="L771">		 jj_expentry[i] = jj_lasttokens[i];</span>
	   }

<span class="nc bnc" id="L774" title="All 2 branches missed.">	   for (int[] oldentry : jj_expentries) {</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">		 if (oldentry.length == jj_expentry.length) {</span>
<span class="nc" id="L776">		   boolean isMatched = true;</span>

<span class="nc bnc" id="L778" title="All 2 branches missed.">		   for (int i = 0; i &lt; jj_expentry.length; i++) {</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">			 if (oldentry[i] != jj_expentry[i]) {</span>
<span class="nc" id="L780">			   isMatched = false;</span>
<span class="nc" id="L781">			   break;</span>
			 }

		   }
<span class="nc bnc" id="L785" title="All 2 branches missed.">		   if (isMatched) {</span>
<span class="nc" id="L786">			 jj_expentries.add(jj_expentry);</span>
<span class="nc" id="L787">			 break;</span>
		   }
		 }
<span class="nc" id="L790">	   }</span>

<span class="nc bnc" id="L792" title="All 2 branches missed.">	   if (pos != 0) {</span>
<span class="nc" id="L793">		 jj_lasttokens[(jj_endpos = pos) - 1] = kind;</span>
	   }
	 }
<span class="nc" id="L796">  }</span>

  /** Generate ParseException. */
  public ParseException generateParseException() {
<span class="nc" id="L800">	 jj_expentries.clear();</span>
<span class="nc" id="L801">	 boolean[] la1tokens = new boolean[36];</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">	 if (jj_kind &gt;= 0) {</span>
<span class="nc" id="L803">	   la1tokens[jj_kind] = true;</span>
<span class="nc" id="L804">	   jj_kind = -1;</span>
	 }
<span class="nc bnc" id="L806" title="All 2 branches missed.">	 for (int i = 0; i &lt; 20; i++) {</span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">	   if (jj_la1[i] == jj_gen) {</span>
<span class="nc bnc" id="L808" title="All 2 branches missed.">		 for (int j = 0; j &lt; 32; j++) {</span>
<span class="nc bnc" id="L809" title="All 2 branches missed.">		   if ((jj_la1_0[i] &amp; (1&lt;&lt;j)) != 0) {</span>
<span class="nc" id="L810">			 la1tokens[j] = true;</span>
		   }
<span class="nc bnc" id="L812" title="All 2 branches missed.">		   if ((jj_la1_1[i] &amp; (1&lt;&lt;j)) != 0) {</span>
<span class="nc" id="L813">			 la1tokens[32+j] = true;</span>
		   }
		 }
	   }
	 }
<span class="nc bnc" id="L818" title="All 2 branches missed.">	 for (int i = 0; i &lt; 36; i++) {</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">	   if (la1tokens[i]) {</span>
<span class="nc" id="L820">		 jj_expentry = new int[1];</span>
<span class="nc" id="L821">		 jj_expentry[0] = i;</span>
<span class="nc" id="L822">		 jj_expentries.add(jj_expentry);</span>
	   }
	 }
<span class="nc" id="L825">	 jj_endpos = 0;</span>
<span class="nc" id="L826">	 jj_rescan_token();</span>
<span class="nc" id="L827">	 jj_add_error_token(0, 0);</span>
<span class="nc" id="L828">	 int[][] exptokseq = new int[jj_expentries.size()][];</span>
<span class="nc bnc" id="L829" title="All 2 branches missed.">	 for (int i = 0; i &lt; jj_expentries.size(); i++) {</span>
<span class="nc" id="L830">	   exptokseq[i] = jj_expentries.get(i);</span>
	 }
<span class="nc" id="L832">	 return new ParseException(token, exptokseq, tokenImage);</span>
  }

  private boolean trace_enabled;

/** Trace enabled. */
  final public boolean trace_enabled() {
<span class="nc" id="L839">	 return trace_enabled;</span>
  }

  /** Enable tracing. */
  final public void enable_tracing() {
<span class="nc" id="L844">  }</span>

  /** Disable tracing. */
  final public void disable_tracing() {
<span class="nc" id="L848">  }</span>

  private void jj_rescan_token() {
<span class="nc" id="L851">	 jj_rescan = true;</span>
<span class="nc bnc" id="L852" title="All 2 branches missed.">	 for (int i = 0; i &lt; 2; i++) {</span>
	   try {
<span class="nc" id="L854">		 JJCalls p = jj_2_rtns[i];</span>

		 do {
<span class="nc bnc" id="L857" title="All 2 branches missed.">		   if (p.gen &gt; jj_gen) {</span>
<span class="nc" id="L858">			 jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;</span>
<span class="nc bnc" id="L859" title="All 3 branches missed.">			 switch (i) {</span>
<span class="nc" id="L860">			   case 0: jj_3_1(); break;</span>
<span class="nc" id="L861">			   case 1: jj_3_2(); break;</span>
			 }
		   }
<span class="nc" id="L864">		   p = p.next;</span>
<span class="nc bnc" id="L865" title="All 2 branches missed.">		 } while (p != null);</span>

<span class="nc" id="L867">		 } catch(LookaheadSuccess ls) { }</span>
	 }
<span class="nc" id="L869">	 jj_rescan = false;</span>
<span class="nc" id="L870">  }</span>

  private void jj_save(int index, int xla) {
<span class="fc" id="L873">	 JJCalls p = jj_2_rtns[index];</span>
<span class="pc bpc" id="L874" title="1 of 2 branches missed.">	 while (p.gen &gt; jj_gen) {</span>
<span class="nc bnc" id="L875" title="All 2 branches missed.">	   if (p.next == null) { p = p.next = new JJCalls(); break; }</span>
<span class="nc" id="L876">	   p = p.next;</span>
	 }

<span class="fc" id="L879">	 p.gen = jj_gen + xla - jj_la; </span>
<span class="fc" id="L880">	 p.first = token;</span>
<span class="fc" id="L881">	 p.arg = xla;</span>
<span class="fc" id="L882">  }</span>

<span class="fc" id="L884">  static final class JJCalls {</span>
	 int gen;
	 Token first;
	 int arg;
	 JJCalls next;
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>